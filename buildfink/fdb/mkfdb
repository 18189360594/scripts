#!/usr/bin/perl

use strict;
use warnings;
use DBI;
use FindBin qw($Bin);

@ARGV >= 2 or die <<EOF;
Usage: $0 dbtype dbstr checkpoint
mkfiledb - Convert a buildfink checkpoint file into a database.
dbstr is a DBI connection string, for instance:
   foo.sqlite
   host:user:pass:db
EOF
my($dbtype, $dbpath) = (shift, shift);

our(%finkfiles, %packages);

# These get replaced by prepared versions when we connect to the database.
our $dbh;
our %dbqueries = (
    add_package => "INSERT INTO packages(package_name) VALUES (?)",
    add_file_path => "INSERT INTO file_paths(parent_id, file_name, fullpath) VALUES (?, ?, ?)",
    add_file_version => <<EOF);
INSERT INTO file_versions(
    package_id,
    is_directory,
    fullpath,
    file_id,
    size,
    posix_user,
    posix_group,
    flags)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
EOF
sub addDBFiles {
    my($file, $parent_id) = @_;

    $dbqueries{add_file_path}->execute($parent_id, $file->{"."}, $file->{"/path/"});
    my $file_id = $dbh->last_insert_id(undef, undef, undef, undef);

    if($file->{"/versions/"}) {
	foreach my $filever (@{$file->{"/versions/"}}) {
	    $dbqueries{add_file_version}->execute(
		$packages{$filever->{pkg}},
		$filever->{isdir},
		$filever->{fullpath},
		$file_id,
		$filever->{size},
		$filever->{user},
		$filever->{group},
		$filever->{flags}
	    );
	}
    }

    foreach my $subfile (keys %$file) {
	next if $subfile eq "." or $subfile eq ".." or $subfile eq "/versions/" or $subfile eq "/path/";
	addDBFiles($file->{$subfile}, $file_id);
    }
}

$finkfiles{"."} = "";
$finkfiles{".."} = undef;
sub addPackageFiles {
    my(undef, $pkg, @files) = @_;

    $packages{$pkg} = 0;
    foreach my $file (@files) {
	my $path = delete $file->{path};
	if(not $path =~ s!^%p/!!) {
	    warn "$pkg has path not in %p: $path\n";
	    next;
	}

	($file->{user}, $file->{group}) = split(m!/!, delete $file->{owners});
	$file->{fullpath} = $path;
	$file->{isdir} = ($file->{flags} =~ /^d/ ? 1 : 0);

	my @pathbits = split(m!/!, $path);

	my $finkroot = \%finkfiles;
	my $fullpath = "";
	foreach my $pathbit(@pathbits) {
	    $fullpath .= "/" if $fullpath;
	    $fullpath .= $pathbit;
	    $finkroot->{$pathbit} ||= {".." => $finkroot, "." => $pathbit, "/path/" => $fullpath};
	    $finkroot = $finkroot->{$pathbit};
	}

	$finkroot->{"/versions/"} ||= [];
	push @{$finkroot->{"/versions/"}}, $file;
	$file->{pkg} = $pkg;
    }
}

while(<>) {
    next unless /^addPackageFiles/;
    s/\$pkgfiles/undef/;
    eval $_;
}

my($dbstr, $dbuser, $dbpass, %dbattrs);
$dbtype = lc($dbtype);
if($dbtype eq "sqlite") {
    $dbstr = "dbi:SQLite:dbname=$dbpath";
    $dbuser = "";
    $dbpass = "";
    %dbattrs = (RaiseError => 1, AutoCommit => 0);
} else {
    die "Unknown database type.  Valid types are: sqlite\n";
}

$dbh = DBI->connect($dbstr, $dbuser, $dbpass, \%dbattrs);
foreach my $key (keys %dbqueries) {
    my $stmt = $dbh->prepare($dbqueries{$key});
    $dbqueries{$key} = $stmt;
}

foreach my $pkg(keys %packages) {
    $dbqueries{add_package}->execute($pkg);
    $packages{$pkg} = $dbh->last_insert_id(undef, undef, undef, undef);
}

foreach my $file(keys %finkfiles) {
    next if $file eq "." or $file eq ".." or $file eq "/versions/" or $file eq "/path/";
    addDBFiles($finkfiles{$file}, 0);
}
$dbh->do("COMMIT");
