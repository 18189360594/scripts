#!/usr/bin/perl -w
#
# flag - housekeeping for Fink's online package database
# Copyright (c) 2001 Christoph Pfisterer
# Copyright (c) 2001-2006 The Fink Package Manager Team
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

$| = 1;
use 5.005;  # perl 5.5 or newer required
use strict;

use DBI;

### settings

my @prio = ( 
    "current-10.4-powerpc-unstable", "current-10.4-powerpc-stable",
    "current-10.4-i386-unstable", "current-10.4-i386-stable",
    "current-10.3-unstable", "current-10.3-stable",
    );

### connect to database

my ($dbh, $sth, $sth2, $q, $mysql_datafile, $mysql_data);
$mysql_datafile = $ENV{HOME}."/.finkdbi";
chomp($mysql_data = `cat $mysql_datafile`);
$dbh = DBI->connect(split(/\|/, $mysql_data));

### reset all flags

$q = "UPDATE package SET latest=0,needtest=0";
$dbh->do($q);

### iterate over package names

$q = "SELECT DISTINCT name FROM package";
$sth = $dbh->prepare($q);
$sth->execute();


while (1) {
  my ($pkgname) = $sth->fetchrow_array;
  last unless defined($pkgname);

  # gather data for all versions in all releases
  $q = "SELECT name,release,version,revision FROM package WHERE name='$pkgname'";
  $sth2 = $dbh->prepare($q);
  $sth2->execute();

  my %vlist = ();  # $release->%v-%r map
  while (1) {
      my ($release, $version, $revision);
      # FIXME: where's the epoch??
    (undef, $release, $version, $revision) = $sth2->fetchrow_array;
    last unless defined($release);
    $vlist{$release} = $version."-".$revision;
  }

  $sth2->finish;

  # set "latest" for the version entry for each package that contains
  # the version-agnostic info to use (Description, etc)
  # FIXME: why aren't we just sorting $sth2 by standard version
  # alogrithm and picking highest?
  # FIXME: Can the dpkg version sorting alogrithm be imlemented in the
  # db itself so that consumers could just ORDER BY and other
  # comparisons instead of needing a script to add sort metadata
  # flags?
  my $chosen = "";
  foreach my $release (@prio) {
      # use the pkg from the first release entry in @prio in which the
      # pkg exists
    if (exists $vlist{$release}) {
      $chosen = $release;
      last;
    }
  }

  if ($chosen eq "") {
      # falback: pkg not found in any @prio releases, so just pick a
      # release where it does exist
    ($chosen) = keys %vlist;
  }

  if ($chosen ne "") {
    $q = "UPDATE package SET latest=1 WHERE name='$pkgname' AND release='$chosen'";
    $dbh->do($q);
  } else {
    print "No release chosen for $pkgname\n";
  }

  # set "needtest" flag for entries of pkgs that are in unstable but
  # not stable, or whose version in stable is different
  if (exists $vlist{$prio[0]} and
      (not exists $vlist{$prio[1]} or $vlist{$prio[0]} ne $vlist{$prio[1]})) {
    $q = "UPDATE package SET needtest=1 WHERE name='$pkgname' AND release='".$prio[0]."'";
    $dbh->do($q);
  }
}
$sth->finish;

### done

$dbh->disconnect;
exit 0;
