#!/usr/bin/perl -w
#
# dump - generate SQL for Fink's online package database
# Copyright (c) 2001 Christoph Pfisterer
# Copyright (c) 2001-2005 The Fink Package Manager Team
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

$| = 1;
use 5.006;  # perl 5.6.0 or newer required
use strict;

### now load the useful modules

use lib qw(basepath/perlmod);
use Fink::Services qw(&read_config &latest_version);
use Fink::Config;
use Fink::Package;
use Fink::Command qw(rm_f);

### read config

my $config = &read_config("fink.conf");

### get parameters
my $distribution = shift || "10.3";
my $tree = shift || "stable";
my $release = shift || "current-$distribution-$tree";

### read package info

# temporarily send stdout to stderr
open(OLDOUT, ">&STDOUT");
open(STDOUT, ">&STDERR") or die "Can't dup stderr";
select(OLDOUT); select(STDOUT);  # keep 'use strict' happy

# if possible, use a symlink $distribution-$tree -> $tree
# so that each .info pathname is unique across all distributions
# (since we may use the dists/ symlink not the actual $distribution dir)
my $treelink = $config->{'basepath'} . "/fink/dists/$distribution-$tree";
rm_f $treelink;
if (-e $treelink) {
    print "Could not remove old $treelink\n";
    undef $treelink;
} else {
    if (symlink $tree, $treelink) {
	$tree = "$distribution-$tree";
    } else {
	print "Could not create symlink $treelink: $!\n";
	undef $treelink;
    }
}

$config->set_param("Trees", "$tree/main $tree/crypto");
# "Trees" is a volatile change vs fink.conf, we don't (and mustn't) call save()

# omit actual locally-installed fink if it is present
set_options({exclude_trees=>[qw/status/]});

# load the package database
Fink::Package->require_packages();

# restore stdout
open(STDOUT, ">&OLDOUT");

### drop the previous data

print "# delete old rows\n";
print "BEGIN;\n";
print "DELETE FROM package WHERE release='$release';\n";
print "DELETE FROM splitoffs WHERE parentkey REGEXP '^$release';\n";

### loop over packages

my ($package, $po, $version, $vo);
my ($maintainer, $email, $desc, $parent);
my ($q, $v, $s, $key, $parentkey, %data, %splitoffdata);

foreach $package (Fink::Package->list_packages()) {
  $po = Fink::Package->package_by_name($package);
  next if $po->is_virtual();
  $version = &latest_version($po->list_versions());
  $vo = $po->get_version($version);
  
  # Skip splitoffs
  #next if $vo->has_parent();

  # gather fields
  $maintainer = $vo->param_default("Maintainer", "(not set)");

  $desc = "<p>".$vo->get_description(1,1);
  $desc =~ s/\s+$//s;
  $desc =~ s/\n/<\/p><p>/s;
  $desc =~ s/\n\s*\.\n/<\/p><p>/sg;
  $desc .= "</p>";
 
  %data = ( 'release' => $release,
	    'fullname' => $vo->get_fullname(),
	    'name' => $vo->get_name(),
	    'version' => $vo->get_version(),
	    'revision' => $vo->get_revision(),
	    'epoch' => $vo->get_epoch(),
	    'descshort' => $vo->get_shortdescription(),
	    'desclong' => $desc,
	    'maintainer' => $maintainer,
	    'license' => $vo->get_license(),
	    'homepage' => $vo->param_default("Homepage", ""),
	    'section' => $vo->get_section()
	  );
	    
  # Determine the splitoff parent of this package
  if ($vo->has_parent()) {
		$data{"parentname"} = $vo->get_parent()->get_name();  # package is a splitoff
  } 

  # generate SQL query
  $q = "INSERT INTO package (";
  $v = ") VALUES (";
  foreach $key (keys %data) {
    $q .= "$key,";
    $s = $data{$key};
    $s =~ s/'/\\'/g;
    $v .= "'$s',";
  }
  $q = substr($q,0,-1).substr($v,0,-1).");";
  # write it
  print "# $package-$version\n";
  print "$q\n";

  if ($vo->has_parent()) {  
	  %splitoffdata = ('name' => $vo->get_name(),
					   'parentkey' => $release . $data{"parentname"},
					   'descshort' => $vo->get_shortdescription()
					   );
	  
	  # generate SQL query
	  $q = "INSERT INTO splitoffs (";
	  $v = ") VALUES (";
	  foreach $key (keys %splitoffdata) {
		$q .= "$key,";
		$s = $splitoffdata{$key};
		$s =~ s/'/\\'/g;
		$v .= "'$s',";
	  }
	  $q = substr($q,0,-1).substr($v,0,-1).");";
  	  print "$q\n";
  }
}

print "COMMIT;\n";
print "OPTIMIZE TABLE package;\n";

### make timestamp

open(OUT,">timestamp.inc") or die "can't write timestamp.inc: $!\n";
print OUT "<?\n\$dyndate = ".time().";\n?>";
close(OUT) or die "can't write timestamp.inc: $!\n";

if (defined $treelink) {
    rm_f $treelink or print "Could not remove $treelink\n";
}

### eof
exit 0;
