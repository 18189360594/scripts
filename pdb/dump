#!/usr/bin/perl -w
# -*- mode: Perl; tab-width: 4; -*-
#
# dump - generate SQL for Fink's online package database
# Copyright (c) 2001 Christoph Pfisterer
# Copyright (c) 2001-2007 The Fink Package Manager Team
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

$| = 1;
use 5.008_001;  # perl 5.8.1 or newer required
use strict;

### now load the useful modules

use lib qw(basepath/perlmod);
use Fink::Services qw(&read_config &latest_version);
use Fink::Config qw(&set_options);
use Fink::Package;
use Fink::Command qw(rm_f);
use File::stat;
use POSIX qw(strftime);

use Getopt::Long;

# temporarily send stdout to stderr
open(OLDOUT, ">&STDOUT");
open(STDOUT, ">&STDERR") or die "Can't dup stderr";
select(OLDOUT); select(STDOUT);  # keep 'use strict' happy

### get parameters
my ($distribution, $release, $architecture, $rel_id, $tree, $wanthelp, $q);

# process command-line
GetOptions(
    'distribution:s' => \$distribution,
    'release:s'      => \$release,
    'architecture:s' => \$architecture,
    'rel_id:s'       => \$rel_id,
    'help'           => \$wanthelp,
    ) or &die_with_usage;
&die_with_usage if $wanthelp;
&die_with_usage if (defined $distribution && not ($distribution =~ /^[0-9a-z.\-]{2,}$/));
&die_with_usage if (defined $release && not ($release =~ m/^[0-9.]{3,}$|^unstable$|^stable$/));
&die_with_usage if (defined $architecture && not ($architecture =~ m/^powerpc$|^i386$/));
#$architecture = 'powerpc' unless defined $architecture;

### connect to database

if (not eval { require DBI }) {
  print "\nWARNING: Unable to connect to DB (DBI Perl module not found!)\n\n";
  if ((not defined $rel_id) || (not $rel_id =~ m/^[0-9]+$/)) {
    die("Call with '--rel_id=...' to specify the corresponing release id. Stopped");
  }
  $tree = $release if (defined $release);
  $tree = 'stable' if (defined $tree && $release =~ m/^[0-9.]{3,}$/);
} else {

### Try to connect to DB

my ($dbh, $sth, $rel, $mysql_datafile, $mysql_data);
$mysql_datafile = "./.finkdbi";
if (not -f $mysql_datafile) {
  $mysql_datafile = $ENV{HOME}."/.finkdbi";
}
chomp($mysql_data = `cat $mysql_datafile`);
$dbh = DBI->connect(split(/\|/, $mysql_data));

### get distributions/releases

$q = "SELECT r.*,d.* FROM `distribution` d ";
$q .= "INNER JOIN `release` r ON r.dist_id = d.dist_id ";
$q .= "WHERE d.active AND r.active ";
if (defined $distribution) {
  $q .= "AND d.identifier='$distribution' ";
}
if (defined $release) {
  if ($release =~ m/^unstable$|^stable$/) {
    $q .= "AND r.type='$release' ";
  } else {
    $q .= "AND r.version='$release' ";
  }
}
if (defined $architecture) {
  $q .= "AND d.architecture='$architecture' ";
}
$q .= "ORDER BY d.priority DESC,r.priority DESC;";

$dbh->do($q);
$sth = $dbh->prepare($q);
$sth->execute();
my $numRows = $sth->rows;
if ($numRows < 1) {
  print "No matching releases found!\n";
} else {
  if ($numRows > 1) {
    print "Found more than one release (sorted by priority):\n";
  } else {
    print "# Dumping packages for release:\n";
  }
  printf "# %3s %12s %8s %8s %8s\n", 'id', 'identifier', 'arch', 'type', 'version';
  while ($rel = $sth->fetchrow_hashref()) {
    printf "# %3s %12s %8s %8s %8s\n", "$rel->{'rel_id'}", "$rel->{'identifier'}", "$rel->{'architecture'}", "$rel->{'type'}", "$rel->{'version'}";
    # Set all values, even if not given on command line
    $rel_id = $rel->{'rel_id'};
    $distribution = $rel->{'identifier'};
    $architecture = $rel->{'architecture'};
    if ($rel->{'type'} eq 'bindist') {
      $tree = 'stable';
    } else {
      $tree = $rel->{'type'};
    }
  }
  printf "\n";
}

$sth->finish();

$dbh->disconnect();

&die_with_usage if ($numRows != 1); # nothing to do

} # if (eval { require DBI })


&die_with_usage if (not defined $distribution);
&die_with_usage if (not defined $release);
&die_with_usage if (not defined $architecture);


### set up our fink

open (BASEPATH, "basepath_fink.inc") || die "couldn't open 'basepath_fink.inc'!";
my $basepath = <BASEPATH>;
close(BASEPATH);
chomp $basepath;

# if possible, use a symlink $distribution-$tree -> $tree
# so that each .info pathname is unique across all distributions
# (since we may use the dists/ symlink not the actual $distribution dir)
my $treelink = "$basepath/fink/dists/$distribution-$tree";
rm_f $treelink;
my $disttree = $tree;
if (-e $treelink) {
    print "Could not remove old $treelink\n";
    undef $treelink;
} else {
    if (symlink $tree, $treelink) {
       $disttree = "$distribution-$tree";
    } else {
	print "Could not create symlink $treelink: $!\n";
	undef $treelink;
    }
}

# simulate a fink.conf; there's no actual file, so don't save() it
my $config = Fink::Config->new_from_properties({
	'basepath'     => $basepath,
	'trees'        => "$disttree/main $disttree/crypto",
	'distribution' => $distribution,
	'architecture' => $architecture,
});

# omit actual locally-installed fink if it is present
set_options({exclude_trees=>[qw/status virtual/]});

# load the package database
Fink::Package->require_packages();

# restore stdout
open(STDOUT, ">&OLDOUT");

### first drop the previous data, then add packages again, doing one 
### release at a time, in one transaction

print "# Begin dump release id = $rel_id\n";
print "START TRANSACTION;\n";
print "# delete old rows\n";
print "DELETE FROM `package` WHERE rel_id='$rel_id';\n";

### loop over packages

my ($package, $po, $version, $vo);
my ($maintainer, $email, $desc, $usage, $parent, $infofile, $infofilechanged);
my ($v, $s, $key, %data, $expand_override);

foreach $package (Fink::Package->list_packages()) {
  $po = Fink::Package->package_by_name($package);
  next if $po->is_virtual();
  $version = &latest_version($po->list_versions());
  $vo = $po->get_version($version);
  
  # Skip splitoffs
  #next if $vo->has_parent();

  # get info file
  $infofile = $vo->get_info_filename();
  if ($infofile) {
    my $sb = stat($infofile);
    $infofile =~ s/$treelink\///s if defined $treelink;
    my $dist_dir = readlink($config->{'basepath'} . "/fink/dists");
    $infofile = "fink/dists/$dist_dir/$tree/$infofile";
    $infofilechanged = strftime "%Y-%m-%d %H:%M:%S", gmtime $sb->mtime;
  }
  
  # gather fields

  $maintainer = $vo->param_default("Maintainer", "(not set)");

  # Always show %p as '/sw'
  $expand_override->{'p'} = '/sw';

  $desc = $vo->param_default_expanded('DescDetail', '',
    expand_override => $expand_override,
    err_action => 'ignore'
  );
  chomp $desc;
  $desc =~ s/\s+$//s;
  $desc =~ s/\n/\\n/g;
 
  $usage = $vo->param_default_expanded('DescUsage', '',
    expand_override => $expand_override,
    err_action => 'ignore'
  );
  chomp $usage;
  $usage =~ s/\s+$//s;
  $usage =~ s/\n/\\n/g;


  # create a summary index field that contains the distinct words in all of the name and desc* fields
  my $word_index = {};
  my $summary_index = join(" ", $vo->get_name(), $vo->get_shortdescription(), $desc, $usage);
  $summary_index =~ s/\\[rn]/ /gs;
  $summary_index =~ s/[^\s\r\n[:alnum:]\:\-\_]+/ /gs;
  for my $word (split(/\s+/s, $summary_index)) {
    $word_index->{lc($word)}++;
  }
  $summary_index = join(" ", sort keys %$word_index);

  %data = ( 
	    'pkg_id' => 'null', # autoincrement
	    'rel_id' => $rel_id,
	    'name' => $vo->get_name(),
	    'version' => $vo->get_version(),
	    'revision' => $vo->get_revision(),
	    'epoch' => $vo->get_epoch(),
	    'descshort' => $vo->get_shortdescription(),
	    'desclong' => $desc,
	    'descusage' => $usage,
	    'maintainer' => $maintainer,
	    'license' => $vo->get_license(),
	    'homepage' => $vo->param_default("Homepage", ""),
	    'section' => $vo->get_section(),
	    'infofile' => $infofile,
	    'infofilechanged' => $infofilechanged,
		'summary_index' => $summary_index,
	  );
	    
  # Determine the splitoff parent of this package
  if ($vo->has_parent()) {
		$data{"parentname"} = $vo->get_parent()->get_name();  # package is a splitoff
  } 

  # generate SQL query
  $q = "INSERT INTO `package` (";
  $v = ") VALUES (";
  foreach $key (keys %data) {
    $q .= "\`$key\`,";
    $s = $data{$key};
    $s =~ s/'/\\'/g;
    $v .= "'$s',";
  }
  $q = substr($q,0,-1).substr($v,0,-1).");";
  # write it
  print "# $package-$version\n";
  print "$q\n";
}
print "COMMIT;\n";
print "OPTIMIZE TABLE `package`;\n";
print "# End dump release id = $rel_id\n";

if (defined $treelink) {
    rm_f $treelink or print "Could not remove $treelink\n";
}





sub die_with_usage {
    die <<EOMSG;
Usage: $0 [options]

Options:
  --distribution
  --release
  --architecture
  --help

'distribution' is the distribution identifier (e.g. '10.4' or '10.2-gcc3.3')
'release' is either a release version (e.g. 0.6.4) for bindists or the strings
  'unstable' or 'stable'
'architecture' is either 'powerpc' or 'i386'
EOMSG
}

### eof
exit 0;


# vim: ts=4 sw=4 noet
